/* auto-generated by NAPI-RS */
/* eslint-disable */
/** RocksDB-based build cache */
export declare class BuildCache {
  /** Create a new build cache at the specified path */
  constructor(cachePath: string)
  /** Get a value from the cache */
  get(key: string): string | null
  /** Set a value in the cache */
  set(key: string, value: string): void
  /** Delete a value from the cache */
  delete(key: string): void
  /** Check if a key exists in the cache */
  has(key: string): boolean
  /** Batch set multiple key-value pairs */
  batchSet(entries: Record<string, string>): void
  /** Clear all entries for a specific target (dev/prod/lib) */
  clearTarget(target: string): number
  /** Clear all cache entries */
  clearAll(): void
  /** Get cache statistics */
  getStats(): CacheStats
  /** Compact the database to reclaim space */
  compact(): void
  /** Close the cache (cleanup) */
  close(): void
}

/** Tokio-based build orchestrator */
export declare class BuildOrchestrator {
  /** Create a new orchestrator with specified parallelism */
  constructor(parallelism?: number | undefined | null)
  /** Log a build event */
  logEvent(stage: string, message: string, durationMs?: number | undefined | null): Promise<void>
  /** Get all logged events */
  getEvents(): Promise<Array<BuildEvent>>
  /** Clear all events */
  clearEvents(): Promise<void>
  /** Execute tasks in parallel */
  executeParallel(taskCount: number): Promise<OrchestratorStats>
  /** Process items in parallel using Rayon */
  processParallelSync(items: Array<string>): Array<string>
  /** Generate deterministic stable ID from content */
  generateStableId(content: string, prefix: string): string
  /** Batch generate stable IDs */
  batchGenerateIds(items: Array<string>, prefix: string): Array<string>
  /** Get orchestrator statistics */
  getStats(): Promise<OrchestratorStats>
  /** Get parallelism level */
  get parallelism(): number
  /** Shutdown the orchestrator */
  shutdown(): void
}

/**
 * High-performance graph analyzer using Integer-based Adjacency List
 * Uses string interning to map Strings <-> usize IDs for O(1) lookups and cache efficiency
 */
export declare class GraphAnalyzer {
  /** Create a new graph analyzer */
  constructor()
  /** Add a node with its dependencies */
  addNode(id: string, dependencies: Array<string>): void
  /**
   * Batch add nodes to minimize NAPI bridge overhead
   * Format: ids list, and flat list of dependencies with counts
   * This avoids creating thousands of small arrays
   */
  addBatch(ids: Array<string>, edges: Array<Array<string>>): void
  /**
   * Detect circular dependencies using Iterative DFS
   * Uses explicit stack to avoid stack overflow on deep graphs (unlike JS recursion)
   */
  detectCycles(): Array<CircularDependency>
  /** Find orphaned nodes (not reachable from any entry point) */
  findOrphanedNodes(entryPoints: Array<string>): Array<string>
  /** Perform complete graph analysis */
  analyze(entryPoints: Array<string>): GraphAnalysisResult
  /** Topological sort using Kahn's algorithm */
  topologicalSort(): Array<string> | null
  /** Get node count */
  nodeCount(): number
  /** Get edge count */
  edgeCount(): number
  /** Clear all nodes */
  clear(): void
}

/** High-performance native worker for plugin transformations */
export declare class NativeWorker {
  /** Create a new native worker with specified pool size */
  constructor(poolSize?: number | undefined | null)
  /**
   * Transform code using a simple regex-based approach
   * In a real implementation, this would load and execute actual plugins
   */
  transformSync(code: string, id: string): string
  /** Async version of transform for non-blocking operations */
  transform(code: string, id: string): Promise<string>
  /** Get the pool size */
  get poolSize(): number
}

export declare class PluginRuntime {
  constructor()
  verifyPlugin(wasmBytes: Uint8Array): boolean
  execute(wasmBytes: Uint8Array, input: string, timeoutMs: number): string
}

/** Batch hash multiple files (parallel processing in future) */
export declare function batchHash(contents: Array<string>): Array<string>

/** Benchmark graph operations */
export declare function benchmarkGraphAnalysis(nodeCount: number, edgeDensity: number): number

/** Benchmark parallel vs sequential processing */
export declare function benchmarkParallelism(itemCount: number): Record<string, number>

/** Benchmark function to compare performance */
export declare function benchmarkTransform(code: string, iterations: number): number

/** Build event for structured logging */
export interface BuildEvent {
  stage: string
  message: string
  timestamp: number
  durationMs?: number
  metadata?: string
}

/** Build stage for orchestration */
export declare const enum BuildStage {
  Init = 'Init',
  Graph = 'Graph',
  Plan = 'Plan',
  DeterminismCheck = 'DeterminismCheck',
  Execute = 'Execute',
  Emit = 'Emit'
}

/** Cache statistics */
export interface CacheStats {
  totalEntries: number
  hits: number
  misses: number
  hitRate: number
  sizeBytes: number
}

export interface CircularDependency {
  cycle: Array<string>
  entryPoint: string
}

/** Create cache key for artifact */
export declare function createArtifactKey(artifactId: string, target: string): string

/** Create cache key for graph hash */
export declare function createGraphKey(graphHash: string): string

/** Create cache key for input fingerprint */
export declare function createInputKey(filePath: string, contentHash: string): string

/** Create cache key for plan hash */
export declare function createPlanKey(planHash: string, target: string): string

/**
 * Fast content hashing for cache keys
 * Uses XXH3 (ultra-fast non-cryptographic hash)
 */
export declare function fastHash(content: string): string

/** Helper function to get optimal parallelism */
export declare function getOptimalParallelism(): number

export interface GraphAnalysisResult {
  hasCycles: boolean
  cycles: Array<CircularDependency>
  orphanedNodes: Array<string>
  entryPoints: Array<string>
  totalNodes: number
  totalEdges: number
}

/**
 * Fast graph operations for dependency analysis
 *
 * Performance-critical operations implemented in Rust:
 * - Circular dependency detection (DFS-based, O(V+E))
 * - Topological sorting (Kahn's algorithm, O(V+E))
 * - Reachability analysis (BFS, O(V+E))
 * - Tree shaking (mark-and-sweep, O(V+E))
 */
export interface GraphNode {
  id: string
  dependencies: Array<string>
}

/** Simple function to test native bindings */
export declare function helloRust(): string

/** Fast string operations for module resolution */
export declare function normalizePath(path: string): string

/** Orchestrator statistics */
export interface OrchestratorStats {
  totalTasks: number
  completedTasks: number
  failedTasks: number
  totalDurationMs: number
  parallelism: number
}

/**
 * Natively scan for imports/requires (Phase 4.2 Hot Path)
 * This is significantly faster than JS-based regex or full AST parsing
 */
export declare function scanImports(code: string): Array<string>
